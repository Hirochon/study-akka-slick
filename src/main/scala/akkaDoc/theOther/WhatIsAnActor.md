# What is an Actor

前節のアクターシステムでは、アクターが階層を形成し、アプリケーションを構築する際の最小単位となることを説明しました。
このセクションでは、そのようなアクターを個別に見て、実装する際に遭遇する概念を説明します。
詳細については、「アクター入門」を参照してください。

1973年にHewitt、Bishop、Steigerによって定義されたアクターモデルは、
計算が分散されることの意味を正確に表現した計算機モデルです。
処理ユニットであるアクターは、メッセージを交換することによってのみ通信することができ、メッセージを受信すると、
アクターは次の3つの基本的な動作を行うことができます。

1. 有限個のメッセージを自分が知っているActorに送る
2. 有限個の新しいアクターを作る
3. 次のメッセージに適用される動作を指定する

アクターは、State、Behavior、Mailbox、Child Actors、Supervisor Strategyのコンテナです。
これらはすべて、アクター・リファレンスの後ろにカプセル化されています。
アクターには明確なライフサイクルがあり、参照されなくなったからといって自動的に破壊されるわけではありません。
アクターを作成した後は、それが最終的に終了することを確認するのはあなたの責任です。

## Actor Reference
後述するように、アクターモデルの恩恵を受けるためには、アクターオブジェクトを外部から遮断する必要があります。
そのため、アクターはアクター参照を使って外部に表現されます。アクター参照は、制限なく自由に受け渡しができるオブジェクトです。
内側と外側のオブジェクトに分割することで、必要な操作をすべて透明化することができます。
たとえば、他の場所で参照を更新することなくアクターを再起動したり、
実際のアクター・オブジェクトをリモート・ホストに配置したり、
どこで実行しているかに関係なくアクターにメッセージを送信したりすることができます。
しかし、最も重要な点は、アクタが不用意にその情報を公開しない限り、
アクタの内部を見て外部からその状態を把握することはできないということです。
n
アクターの参照はパラメータ化されており、指定されたタイプのメッセージのみを送信することができます。

## State
アクターオブジェクトは、通常、アクターが取り得る状態を反映したいくつかの変数を含みます。
これは、明示的なステートマシンの場合もあれば、カウンター、リスナーのセット、保留中のリクエストなどの場合もあります。
これらのデータは、アクタの価値を高めるものであり、他のアクタによる破壊から保護する必要があります。
良いニュースは、Akkaのアクターは概念的にそれぞれ独自の軽量スレッドを持っており、
システムの他の部分から完全に保護されていることです。
つまり、ロックを使ってアクセスを同期させる代わりに、並行性をまったく気にせずにアクターコードを書くことができるのです。

舞台裏では、Akka はアクターのセットを実際のスレッドのセットで実行します。
通常、多くのアクターが 1 つのスレッドを共有し、1 つのアクターの後続の呼び出しが異なるスレッドで処理されることがあります。
Akka は、この実装の詳細が、アクターの状態を処理する際のシングルスレッド性に影響しないことを保証します。

内部状態はアクタの操作に不可欠であるため、状態に一貫性がないことは致命的です。
そのため、アクタが故障してスーパーバイザーによって再起動されると、アクタを最初に作成したときのように、
状態がゼロから作成されます。これは、システムの自己修復機能を有効にするためです。

オプションとして、受信したメッセージを永続化し、再起動後に再生することで、
アクターの状態を再起動前の状態に自動的に回復することができます（「イベント・ソーシング」を参照）。

## Behavior
メッセージが処理されるたびに、そのメッセージはアクターの現在のビヘイビアと照合されます。
振る舞いとは、その時点でのメッセージに対する反応として取るべきアクションを定義する関数を意味します。
例えば、クライアントが認可されている場合はリクエストを転送し、そうでない場合は拒否します。
例えば、クライアントが認証されていればリクエストを転送し、認証されていなければ拒否するといったものです。
この動作は時間の経過とともに変化する可能性があります。
例えば、時間の経過とともに異なるクライアントが認証を取得する場合や、
アクターが「サービス停止」モードに入り、後に復帰する場合などです。
このような変更は、ビヘイビア・ロジックから読み込まれるステート変数にエンコードするか、
次のメッセージに使用される別のビヘイビアを返すことで、関数自体を実行時に交換することで実現されます。
ただし、アクター・オブジェクトの構築時に定義された初期ビヘイビアは、
アクターを再起動するとそのビヘイビアがこの初期ビヘイビアにリセットされるという意味で、特別なものです。

メッセージはアクターリファレンスに送ることができますが、
このファサードの背後にはメッセージを受信してそれに基づいて動作するビヘイビアがあります。
アクターリファレンスとビヘイビアの間のバインディングは時間の経過とともに変更されることがありますが、それは外部からは見えません。

アクター・リファレンスはパラメータ化されており、指定されたタイプのメッセージのみを送信することができます。
アクター参照とそのタイプ・パラメータの関連付けは、アクター参照（およびそのアクター）の作成時に行う必要があります。
この目的のために、各ビヘイビアは処理できるメッセージのタイプもパラメータ化されています。
ビヘイビアは、アクター参照のファサードの後ろで変更される可能性があるため、次のビヘイビアを指定することは、
制約のある操作になります。これは、このActorを参照しているアクター参照を無効にしないために必要です。

これにより、メッセージがActorに送信されるときに、
メッセージのタイプがActorが処理することを宣言しているものであることを静的に保証することができ、
まったく無意味なメッセージを送信するという失敗を避けることができます。
しかし、メッセージを受信したときに、アクター参照の背後にある動作が所定の状態にあることを静的に保証することはできません。
根本的な理由は、アクター参照とビヘイビアの関連性が動的なランタイム・プロパティであり、
コンパイラがソース・コードを翻訳している間にそれを知ることができないからです。

これは、内部変数を持つ通常のJavaオブジェクトと同じです。
プログラムをコンパイルするときに、その値を知ることはできません。
また、メソッド呼び出しの結果がそれらの変数に依存する場合、結果はある程度不確実です。

アクター・コマンドの返信メッセージ・タイプは、メッセージ内に含まれる reply-to のアクター参照のタイプによって記述されます。
返信メッセージはタイプAですが、タイプBのアドレスが含まれている場合もあります。
この場合、他のアクターはタイプBのメッセージをこの新しいアクター参照に送信して会話を続けることができます。
アクターの「現在の」状態を静的に表現することはできないが、2つのアクター間のプロトコルの現在の状態は、
最後に受信または送信されたメッセージタイプによって与えられるので、表現することができる。

## Mailbox
アクターの目的はメッセージの処理であり、
これらのメッセージは他のアクター（またはアクター・システムの外部）からアクターに送信されたものです。
送信者と受信者をつなぐのは、アクターのメールボックスです。
各アクターは、送信者がメッセージをエンキューするメールボックスを1つだけ持っています。
エンキューは、送信操作の時間順に行われます。
つまり、異なるアクターから送信されたメッセージは、スレッドにアクターを分散させるという見かけ上のランダム性のため、
ランタイムには定義された順序にならない可能性があります。
一方、同じアクターから同じターゲットに複数のメッセージを送信すると、同じ順序でエンキューされます。

メールボックスの実装にはさまざまなものがありますが、デフォルトはFIFOです。
アクターによって処理されたメッセージの順序は、エンキューされた順序と一致します。
通常、これは良いデフォルトですが、アプリケーションでは、
あるメッセージを他のメッセージよりも優先させる必要があるかもしれません。
このような場合、優先メールボックスは、常に最後ではなく、メッセージの優先度によって与えられた位置でエンキューしますが、
最前面の場合もあります。このようなキューを使用している場合、処理されるメッセージの順序は、
当然ながらキューのアルゴリズムによって定義され、一般的にFIFOではありません。

Akka が他のアクターモデルの実装と異なる重要な特徴は、
現在の動作が常に次のデキューされたメッセージを処理しなければならないということで、
次にマッチするメッセージのためにメールボックスをスキャンすることはありません。
この動作がオーバーライドされていない限り、メッセージの処理に失敗すると、通常は失敗として扱われます。