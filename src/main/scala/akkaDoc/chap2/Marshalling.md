# Marshalling

マーシャリングとは、**上位（オブジェクト）の構造**を、
**ある種の下位表現（多くの場合、「ワイヤ・フォーマット」）に変換するプロセス**です。
マーシャリングの他の一般的な名称は、「**シリアライゼーション**」または「**ピックリング**」です。

Akka HTTP では、マーシャリングとは、**T 型のオブジェクトを低レベルのターゲット型に変換すること**を意味します。
例えば、**MessageEntity（HTTP リクエストやレスポンスの「エンティティボディ」を形成する）**や、
完全な **HttpRequest や HttpResponse **などです。

例えば、サーバ側では、アプリケーション・ドメイン・オブジェクトを
レスポンス・エンティ ティに変換するために マーシャリングが使用されます。
リクエストには、application/json や application/xml など、
クライアントが受け入れ可能なコンテンツ・タイプを列挙する Accept ヘッダを含めることができます。
マーシャラーには、Accept と AcceptCharset ヘッダーに基づいて
結果のコンテントタイプをネゴシエートするロジックが含まれています。

## Basic Design
A型のインスタンスからB型のインスタンスへのマーシャリングは、Marshaller[A, B]によって行われます。

当初の予想に反して、Marshaller[A, B]は単なる関数A => Bではなく、
**本質的には関数A => Future[List[Marshalling[B]]]** です。

マーシャラーがなぜこのように設計されているのかを理解するために、
このかなり複雑に見えるシグネチャーを1つ1つ分解してみましょう。

A型のインスタンスが与えられると、Marshaller[A, B]は以下のものを生成します。

1. 未来です。マーシャラーは同期的に結果を生成する必要はないので、代わりにフューチャーを返します。 
2. リストの マーシャラーは、Aのターゲットとなる表現を1つだけではなく、複数の表現を提供することができます。
   最終的にどの表現がワイヤー上にレンダリングされるかは，コンテントネゴシエーションによって決定されます。
   例えば、Marshaller[OrderConfirmation, MessageEntity]は、XML表現だけでなく、**JSON表現**も提供することができます。
   クライアントは、Acceptリクエストヘッダーを追加することで、どちらを優先するかを決めることができます。
   クライアントが好みを表明しない場合は、最初の表現が選ばれます。
3. Marshalling[B]の場合 マーシャラーは、Bのインスタンスを直接返すのではなく、 まずMarshalling[B]を生成します。
   これにより、実際のマーシャリングが開始される前に、
   マーシャラーが生成するMediaTypeと潜在的にHttpCharsetを照会することができます。
   コンテント・ネゴシエーションを可能にすることとは別に、
   このデザインは、マーシャリング・ターゲット・インスタンスの実際の構築を、
   それが本当に必要とされる最後の瞬間まで遅らせることを可能にします。
   
